\section{Background}
\label{sec:background}
% brief origin/background of memory compilers

% Existence of memory compilers from the beginning
Memory compilers have been used in Electronic Design Automation (EDA)
design flows to reduce the design
time long before contemporary
compilers~\cite{broderson:sicompiler,johannsen:blocks}.
However, these compilers were generally not portable as they were 
nothing more
than quick scripts to aid designers. Porting to a new technology
essentially required rewriting the scripts. However, the increase in
design productivity when porting designs between technologies has led to
more research on memory array
compilers~\cite{cabe:flexible,huang:array,poechmueller:array,Xu:2007}.

% Reason why compilers evolved to today's current version
As technology entered the Deep Sub-Micron (DSM) era, memory designs
became one of the most challenging parts of circuit design
due to decreasing static noise margins (SNM), increasing fabrication
variability, and increasing leakage power consumption. 
This increased the complexity of memory compilers dramatically as they had to
adapt to the ever-changing technologies. Simultaneously, design
methodologies shifted from silicon compilers to standard cell place
and route methods which required large optimized libraries. During
this time, industry began using third-party suppliers of standard cell
libraries and memory compilers that allowed their reuse to amortize
development costs. These next-generation memory compilers provided
silicon-verification that allowed designers to focus on their new
design contribution rather than time-consuming tasks such as memory
generation.

% Commercial industry memory compilers' description and cost
Contemporary memory compilers have been widely used by industry, but
the internal operation is typically hidden. Several prominent
companies and foundries have provided memory compilers to their
customers. These memory compilers usually allow customers to view
front-end simulation, timing/power values, and pin locations after a
license agreement is signed. Back-end features such as layout are
normally supplied directly to the fab and are only given to the user
for a licensing fee.

% Examples of commercial compilers' drawbacks
Specifically, Global Foundries offers front-end PDKs for free, but not
back-end detailed views~\cite{globalfoundries:2015}.  Faraday
Technologies provides a \enquote{black box} design kit where users do
not know the details of the internal memory
design~\cite{faraday:2015}. Dolphin Technology offers closed-source
compilers which can create RAMs, ROMs, and CAMs for a variety of
technologies~\cite{dolphin:2015}. The majority of these commercial
compilers do not allow the customer to alter the base design, are
restricted by the company's license, and usually require a fee. This
makes them virtually unavailable and not useful for many academic
research projects.

% Describe the problem (no free open-source that is widely distributed)
In addition to memory compilers provided by industry, various research
groups have released scripts to generate memories. However, these
designs are not silicon verified and are usually only composed of
simple structures.  For example, FabMem is able to
create small arrays, but it is highly dependent on the Cadence design
tools~\cite{fabmem:2010}. The scripts do not provide any characterization capability
and cannot easily integrate with commercial place and route tools.

% Industry's attempt to provide academia a memory compiler
Another recent, promising solution for academia is the Synopsys
Generic Memory Compiler (GMC)~\cite{Goldman:2014}. The software is
provided with sample generic libraries such as Synopsys' $32$/$28$nm and
$90$nm abstract technologies and can generate the entire SRAM for these
technologies. The GMC generates GDSII layout data, SPICE netlists,
Verilog and VHDL models, timing/power libraries, and DRC/LVS
verification reports. GMC, however, is not recommended for
fabrication since the technologies it supports are not real. Its sole
purpose is to aid students in VLSI courses to learn about using
memories in design flows.

% Academia's' attempts at a memory compiler
There have been multiple attempts by academia to implement a memory
compiler that is not restricted: the Institute of
Microelectronics' SRAM IP Compiler~\cite{Xu:2007}, School of
Electronic Science and Engineering at Southeast University's Memory IP
Compiler~\cite{Chen:2012}, and Tsinghua University's Low Power SRAM
Compiler~\cite{Wu:2010}. These are all methodologies and design flows
for a memory compiler, but there are no public releases.

% State what we are looking for in academia. -- duplicate from introduction
%% With all these attempts, there still isn't a complete solution for
%% academia's research needs.  Researchers need a memory compiler that is
%% open-source, platform- and tool-portable, technology independent, and
%% can generate fabricable memory designs.

                                                     
